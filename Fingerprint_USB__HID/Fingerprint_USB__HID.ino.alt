// Fingerabdruck Passwort Eingabe über USB HID Keyboard Emulator
// fingerprint usb hid keyboard
// Resistiven Touchscreen Panel als USB Macro Keypad 
// shortcuts programmierbare Keyboard
// Frei Programmierbare USB Makro Tastatur
// Arduino Leonardo Micro + Touchscreen Panel

// Befehlformat: "§", Befehl, Wert, Leerzeichen (Beispiel "Wort1§t1000 Wort2" Befehl warte 1 sekunde)
// §p - Press         "§p0x80 "  Strg drücken
// §r - Release       "§r0x80 "  Strg loslassen
// §a - Release All   "§a "      Alle Tasten Loslassen
// §w - Write         "§w0xB0 "  Enter klicken
// §t - Timer         "§t3000  " 3 Sekunden abwarten
// Scancodes Zuordnung bitte hier entnehmen
// https://github.com/arduino-libraries/Keyboard/blob/master/src/Keyboard.h

#define Datensaetze 10
const String data[Datensaetze] =
{
"1§w0xB0 ", "2§w0xB0 ","contramutator§w0xB0 ","478344§w0xB3 1475963§w0xB0 ","5§w0xB0 ",
"6§w0xB0 ","7§w0xB0 ","8§w0xB0 ","9§w0xB0 ","10§w0xB0 "
};

#include <stdint.h>
#include "KeyboardDE.h"
#include <Adafruit_Fingerprint.h>

#define mySerial Serial1
#define TouchSensor 2

Adafruit_Fingerprint finger = Adafruit_Fingerprint(&mySerial);



// ---------------- Setup ------------------------------------------

void setup(void)
{
  Serial.begin(115200);
  finger.begin(57600);
  pinMode(TouchSensor, INPUT); 
  pinMode(TouchSensor, INPUT); 
  if (finger.verifyPassword() and Serial)Serial.println("Fingerabdrucksensor angeschlossen");
  Keyboard.begin();
}

uint8_t id;

void loop(void) 
{ 
while (digitalRead(TouchSensor))
  {
    int FingerID = getFingerprintIDez();
    if (Serial)
    {
      if (FingerID<0) Serial.println("Nicht gefunden");
      else
      {
          Serial.print("Gefunden ID #");
          Serial.println(FingerID);
      }
    }
    else
    {
    if (FingerID>0)KeyOutput(data[FingerID-1]);
    }
  }  
if (Serial.available())     //Wenn Eingabe erfolgt
  {
    char  Wahl = Serial.read();     //Hole eingegebenes Zeichen
    Serial.flush();
    Serial.println(Wahl);     //Zeige eingegebenes Zeichen
    switch (Wahl)             //Auswahlsteuerung
    {
      case 'r':
        Serial.println("Bitte ID eingeben");
        id = readnumber();
          if (id == 0) 
          {// ID #0 not allowed, try again!
              break;
          }
          Serial.print("Speicher ID #");
          Serial.println(id);
          while (!  getFingerprintEnroll() )  delay(100);
        break;
      case 'l': // Löschen
      Serial.println("Bitte gebe die ID zum Löschen");
        id = readnumber();
          if (id == 0) 
          {// ID #0 not allowed, try again!
              break;
          }
          Serial.print("ID #");
          Serial.print(id);
          Serial.println(" Löschen? j/n");
          Serial.flush();
          while (!Serial.available());
          Wahl = Serial.read();
          Serial.println(Wahl);
          if ( Wahl == 'j') deleteFingerprint(id);
        break;
    } // Auswahl
  }   // Wenn Eingabe erfolgt
}

uint8_t deleteFingerprint(uint8_t id) {
  uint8_t p = -1;

  p = finger.deleteModel(id);

  if (p == FINGERPRINT_OK) {
    Serial.println("Gelöscht!");
  } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
    Serial.println("Communication error");
    return p;
  } else if (p == FINGERPRINT_BADLOCATION) {
    Serial.println("Falsche ID");
    return p;
  } else if (p == FINGERPRINT_FLASHERR) {
    Serial.println("Error writing to flash");
    return p;
  } else {
    Serial.print("Unknown error: 0x"); Serial.println(p, HEX);
    return p;
  }
}
uint8_t getFingerprintEnroll() {

  int p = -1;
  Serial.print("Waiting for valid finger to enroll as #"); Serial.println(id);
  while (p != FINGERPRINT_OK) {
    p = finger.getImage();
    switch (p) {
    case FINGERPRINT_OK:
      Serial.println("Image taken");
      break;
    case FINGERPRINT_NOFINGER:
  //    Serial.println(".");
      break;
    case FINGERPRINT_PACKETRECIEVEERR:
      Serial.println("Communication error");
      break;
    case FINGERPRINT_IMAGEFAIL:
      Serial.println("Imaging error");
      break;
    default:
      Serial.println("Unknown error");
      break;
    }
  }

  // OK success!

  p = finger.image2Tz(1);
  switch (p) {
    case FINGERPRINT_OK:
      Serial.println("Abbildung umgewandelt");
      break;
    case FINGERPRINT_IMAGEMESS:
      Serial.println("Abbildung undeutlich");
      return p;
    case FINGERPRINT_PACKETRECIEVEERR:
      Serial.println("Communication error");
      return p;
    case FINGERPRINT_FEATUREFAIL:
      Serial.println("Could not find fingerprint features");
      return p;
    case FINGERPRINT_INVALIDIMAGE:
      Serial.println("Could not find fingerprint features");
      return p;
    default:
      Serial.println("Unknown error");
      return p;
  }

  Serial.println("Finger entfernen");
  delay(2000);
  p = 0;
  while (p != FINGERPRINT_NOFINGER) {
    p = finger.getImage();
  }
  Serial.print("ID "); Serial.println(id);
  p = -1;
  Serial.println("Bitte den gleichen Finger auflegen");
  while (p != FINGERPRINT_OK) {
    p = finger.getImage();
    switch (p) {
    case FINGERPRINT_OK:
      Serial.println("Abbildung erhalten");
      break;
    case FINGERPRINT_NOFINGER:
 //     Serial.print(".");
      break;
    case FINGERPRINT_PACKETRECIEVEERR:
      Serial.println("Communication error");
      break;
    case FINGERPRINT_IMAGEFAIL:
      Serial.println("Imaging error");
      break;
    default:
      Serial.println("Unknown error");
      break;
    }
  }

  // OK success!

  p = finger.image2Tz(2);
  switch (p) {
    case FINGERPRINT_OK:
      Serial.println("Image converted");
      break;
    case FINGERPRINT_IMAGEMESS:
      Serial.println("Image too messy");
      return p;
    case FINGERPRINT_PACKETRECIEVEERR:
      Serial.println("Communication error");
      return p;
    case FINGERPRINT_FEATUREFAIL:
      Serial.println("Could not find fingerprint features");
      return p;
    case FINGERPRINT_INVALIDIMAGE:
      Serial.println("Could not find fingerprint features");
      return p;
    default:
      Serial.println("Unknown error");
      return p;
  }

  // OK converted!
  Serial.print("Creating model for #");  Serial.println(id);

  p = finger.createModel();
  if (p == FINGERPRINT_OK) {
    Serial.println("Prints matched!");
  } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
    Serial.println("Communication error");
    return p;
  } else if (p == FINGERPRINT_ENROLLMISMATCH) {
    Serial.println("Fingerprints did not match");
    return p;
  } else {
    Serial.println("Unknown error");
    return p;
  }

  Serial.print("ID "); Serial.println(id);
  p = finger.storeModel(id);
  if (p == FINGERPRINT_OK) {
    Serial.println("Stored!");
  } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
    Serial.println("Communication error");
    return p;
  } else if (p == FINGERPRINT_BADLOCATION) {
    Serial.println("Could not store in that location");
    return p;
  } else if (p == FINGERPRINT_FLASHERR) {
    Serial.println("Error writing to flash");
    return p;
  } else {
    Serial.println("Unknown error");
    return p;
  }

  return true;
}

int getFingerprintIDez() 
{
  uint8_t p = finger.getImage();
  if (p != FINGERPRINT_OK)  return -1;

  p = finger.image2Tz();
  if (p != FINGERPRINT_OK)  return -1;

  p = finger.fingerSearch();
  if (p != FINGERPRINT_OK)  return -1;

  return finger.fingerID;
}

uint8_t readnumber(void) {
  uint8_t num = 0;

  while (num == 0) {
    while (! Serial.available());
    num = Serial.parseInt();
  }
  return num;
}


// ---------------- HEX String in Integer umwandeln  -----------------------

unsigned int hexToDec(String hexString)
{

  unsigned int decValue = 0;
  int nextInt;
  hexString.toUpperCase();
  for (int i = 0; i < hexString.length(); i++)
  {
    nextInt = int(hexString.charAt(i));
    if (nextInt >= 48 && nextInt <= 57) nextInt = map(nextInt, 48, 57, 0, 9);
    if (nextInt >= 65 && nextInt <= 70) nextInt = map(nextInt, 65, 70, 10, 15);
    if (nextInt >= 97 && nextInt <= 102) nextInt = map(nextInt, 97, 102, 10, 15);
    nextInt = constrain(nextInt, 0, 15);
    decValue = (decValue * 16) + nextInt;
  }
  return decValue;
}



// ---------- Ausgabe des Textes über HID-Keybord und Ausführung der Befehle -----

void KeyOutput(const String str)
{
  int pos = str.indexOf('§');
  while (pos >= 0)
  {
    if (pos > 0) Keyboard.print(str.substring(0, pos - 1));
    str.remove(0, pos + 1);
    char kode = str.charAt(0);
    pos = str.indexOf(' ');
    String Daten = str.substring(1, pos);
    byte z;
    switch (kode)             // Befehle
    {
      case 'w':
        z = hexToDec(Daten);
        Keyboard.write(z);
        break;
      case 't':
        delay(Daten.toInt());
        break;
      case 'p':
        z = hexToDec(Daten);
        Keyboard.press(z);
        break;
      case 'r':
        z = hexToDec(Daten);
        Keyboard.release(z);
        break;
      case 'a':
        Keyboard.releaseAll();
        break;
    }
    str.remove(0, pos + 1);
    pos = str.indexOf('§');
  }
  if (str.length() > 0)Keyboard.print(str);
}
